import os
import inspect
import os.path as osp
import subprocess
import sys

try:
    from jinja2 import Environment, PackageLoader
except:
    pass

import vim

from babelide.utils import install_virtual_env
from babelide.utils import install_package

from babelide.plugins.base import BabelIDE_Base_Plugin
from babelide.plugins.html5 import BabelIDE_HTML5_Plugin

class IDEManager(object):
    """Docstring for BabelIDE_Manager """

    def __init__(self):
        """@todo: Constructor """

    def init(self, babelide_basedir):
        """Initialize the plugin

        """

        self.__basedir = babelide_basedir

        # setup workarea
        self.__workarea = osp.join(self.__basedir, 'workarea')
        if not osp.exists(self.__workarea):
            os.makedirs(self.__workarea)

        # check if the virtual env is setup
        self.__virtualenv_path = osp.join(babelide_basedir, 'pyenv')
        exit_on_init = False
        if not osp.exists(self.__virtualenv_path):
            install_virtual_env( babelide_basedir )
            exit_on_init = True
        
        self.__python_exe = osp.join(self.__virtualenv_path, 'bin', 'python')
        self.__easyinstall_exe = osp.join(self.__virtualenv_path, 'bin',
                'easy_install')

        self.update_packages()

        if exit_on_init:
            self.exit_on_init()


        # setup global data structures
        self.__plugins = []
        self.__actions = {}

        # load ide plugins
        self._loadBase()
        self._loadHTML5()

        # accumulate data for wrapper generation
        self._accumulate_plugin_functions()
        self._accumulate_plugin_mappings()
        self._accumulate_plugin_actions()

        # build vim script of plugin wrappers
        self._build_wrapper_file()

    def exit_on_init(self):
        """Exit after virtualenv created to allow for restarting vim's python
        runtime.

        """
        print('*'*80)
        print('    Please restart vim')
        print('*'*80)

        vim.command('exit()')

    def destroy(self):
        """This is a cleanup method that gets called on vim exit"""
        # remove autogenerated plugin wrapper file
        
        pass

    def update_packages(self, force=False):
        """Run python setup.py develop to install new packages

        :force: Force the update

        """
        touch_file = osp.join(self.__workarea, 'packagesupdated')

        if force:
            os.remove(touch_file)
    
        # update virtualenv with new packages, if necessary
        if not osp.exists(touch_file):
            proc = subprocess.Popen(
                    [self.__python_exe,
                        'setup.py',
                        'develop'])
            proc.wait()

            subprocess.Popen('touch {}'.format(touch_file), shell=True)

    def _loadBase(self):
        """Load the base functionality for the IDE"""
        self.__plugins.append( BabelIDE_Base_Plugin(self) )

    def _loadHTML5(self):
        """Load the html5 plugin

        """
        self.__plugins.append( BabelIDE_HTML5_Plugin(self) )

    def _accumulate_plugin_functions(self):
        """Accumulate the public functions that will be exposed to vimscript for
        the plugin objects

        """
        all_funcs = {}
        for plugin in self.__plugins:
            plugin_name = plugin.__class__.__name__
            plugin_name = plugin_name.replace('BabelIDE_', '')
            plugin_name = plugin_name.replace('_Plugin', '')
            all_funcs.update( { '{}_{}'.format(plugin_name, x[0]):x[1] 
                for x in inspect.getmembers(plugin, inspect.ismethod)} )
        
        exposed_funcs = {x:y for x,y in all_funcs.iteritems() if hasattr(y, '__exposed__')}

        self.__exposed_funcs = exposed_funcs

    def _accumulate_plugin_mappings(self):
        """Accumulate key mappings from plugin objects

        """
        pass

    def _accumulate_plugin_actions(self):
        """Accumulate that the plugins expose
        """
        for plugin in self.__plugins:
            self.__actions.update(plugin.get_actions())

    def _build_wrapper_file(self):
        """Build the vimscript wrapper file to expose all the functionality
        :returns: @todo

        """
        gen_vimscript = osp.join(self.__workarea, 'autogen_vimscript.vim')

        if osp.exists(gen_vimscript):
            os.remove(gen_vimscript)

        with open(gen_vimscript, 'w') as f:

            env = Environment(loader=PackageLoader('babelide'))
            autogen_template = env.get_template('autogen_vimscript.tplvim')

            template_data = {
                'functions': self.__exposed_funcs
                }

            f.write( autogen_template.render(template_data) )

    def call_entry_point(self, entry_point):
        """Call a function entry point from one of the plugins"""
        
        plugin_name, func = entry_point.split('_', 1)
        for plugin in self.__plugins:
            class_name = 'BabelIDE_{}_Plugin'.format(plugin_name)
            if plugin.__class__.__name__ == class_name:
                getattr(plugin, func)()

    def get_action_list(self, filetype):
        """ Return the list of actions for a particular filetype"""
        return self.__actions.get(filetype, {})



# setup main  ide manager singleton
BabelIDE_Manager = IDEManager()
